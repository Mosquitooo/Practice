
	item 1: 指针与引用
		引用：任何情况下都不能是引用指向空值，引用必须被初始化. 并且不能重新赋值.
		指针：指针可以指向空值, 并且可以重新赋值
	
	item 2：尽量使用c++风格类型的转换(cast)
		static_cast: 基本类型之间进行转换 int <-> double
		const_cast: 转换掉对象的const属性
		dynamic_case: 沿着类的继承关系向下进行类型转换，不能被用于缺乏虚函数的类型上
		reinterpret_cast： 在函数指针类型之间进行转换
	
	item 3: 不要对数组使用多态
		数组寻址：a[i] = i*sizeof(A);
		当对数组使用多态时, 使用的是基类A的大小而不是派生类的大小.
	
	item 4: 避免无用的缺省构造函数
	
	

	item 5: 谨慎定义类型转换函数
		
	
	item 6: ++ --的前缀后缀形式
		前缀返回一个引用， 后缀返回const类型
		如果需要提高代码效率，那么使用前缀， 后缀必须建立一个临时对象作为返回值，承担了这个对象的构造和析构成本
		
	item 7：不要重载 && || ,
		短路求值法：一旦确定了布尔表达式的真假值，布尔表达式将停止运算。 if( (p !=0 ) && strlen(p) > x) 正确
		函数调用法：函数调用需要计算所有参数，if(operator&&(p, strlen(p)))  将产生灾难
		如果重载了 && ||, 表达式执行的是函数调用法。
		
	item 8：理解各种不同的new delete
		new: 分配内存并且调用构造函数
		operator new： 只分配内存

异常：
	item 9:  使用析构函数防止资源泄漏
	item 10: 使用构造防止内存泄漏
		使用智能指针
		
		
	item 11：别让异常逃离构造和析构 
		一：确保在异常传递过程中，terminate被调用导致程序终止
		二：确保析构函数总能完成我们希望它做的事

效率：
	item 16：80/20法则
		80%的时间都是在%20的代码上.
	
	item 17: 考虑使用懒惰计算法
		延迟到真正使用变量的时候
		
	item 19：理解临时对象的来源
		一：任何时候见到常量引用参数，就存在临时对象绑定在参数上的可能
		二：只要函数返回对象，就有一个临时对象被建立
	
	item 20：返回值优化
		通过使用函数的return位置来消除函数局部对象
	
	item 21: 通过重载避免隐式类型转换
		每一个重载的operator, 必须带有一个用户自定义类型的参数
		
	item 22：考虑用运算符的赋值形式（op=）取代其单独形式（op）
			x+=y; 代替 x = x + y;
			
	item 23: 考虑变更程序库
		
	item 24：理解虚拟函数、多继承、虚基类和 RTTI 所需的代价
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		