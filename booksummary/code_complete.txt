

第六章: 可以工作的类
	6.1 抽象数据类型
		抽象数据类型指一组数据和对数据操作的集合。
		优点：
			1. 隐藏实现细节，改动不会影响整个程序
			2. 无需在程序内到处传递数据

	6.2 良好的类接口
		1. 类接口应该展现一致的抽象层次
		2. 检查每一个接口是否需要一个互补的操作
		3. 如果一个类中一般函数使用一半数据，另一半使用另外的，拆开他们！

		封装
			1. 尽可能限制类和成员的可访问性
			2. 不要公开暴露成员数据
			3. 不要对类的使用者做出假设
			4. 避免使用友元类

	6.3 设计和实现的问题
		1. 聚合
		2. 继承
			1. 只继承需要继承的部分
			2. 派生后覆盖了某个子程序却不做任何事，这种情况值得思考
			3. 尽量使用多态，避免不必要的类型检查。
		3. 数据成员和函数
			1. 类中的成员尽可能的少
			2. Demeter法则，对其它类的调用要尽可能少
		4. 构造函数
			1. 尽可能在所有构造函数中初始化所有成员
			2. 用私有化构造函数来实现单件属性
			3. 优先采用深拷贝，除非论证可行，才使用浅拷贝。
	6.4 创建类的原因
		1. 为现实世界中的对象建模(打印机)
		2. 为抽象对象建模(形状)
		3. ...
	6.5 

第七章: 高质量的子程序
	7.1 创建子程序的正当理由
		1. 降低复杂度、避免代码重复
		2. 支持子类化(派生)
		3. 隐藏调用顺序、指针操作，提高可移植性
		4. 简化复杂的bool判断

	7.2 在子程序层上设计
		1. 可取的内聚性
			顺序内聚性:(子程序调用其它的子程序)
			通信内聚性:(不同操作使用了同样数据、本身没什么联系，可拆分)
			临时内聚性:Init()函数
		2. 不可取的内聚性
			过程内聚性: 子程序必须按特定顺序进行
			逻辑内聚性: 禁止在参数上加BOOL来控制不同的操作
			无内聚性

	7.3 好的子程序名字
	7.4 子程序可以写多长: 50~150行
	7.5 如何使用子程序参数
		顺序：输入参数->输入输出参数->输出参数->错误码
	7.6 函数和过程
		函数：具有返回值且只有输入参数
		过程: 无返回值
	7.7 宏和内联
		尽量用内联代替宏

第八章：防御式编程
	8.1 